# Advices to writing code
## Naming rules
1) Стоит избегать неявной типизации типа ```var```.
2) Переменные должны иметь осмысленные названия.  
**```string Name``` лучше, чем ```var a```.**
3) Объекты должны иметь имена, которые легко произносить.  
**```string IntervalInMilliseconds``` лучше, чем ```string IntvrlInMs```.** 
4) Однобуквенные имена только для для локальных переменных в коротких методах.  
```c#
private void Keyboard_KeyUp(object sender, KeyRoutedEventArgs e)
  {
    if (e.key == VirtualKey.A)
      {
        // do something
      }
  }        
```
5) Не использовать сокращение имен.  
**```AudioGraphService``` лучше, чем ```AudioGraphSVC```.**
6) Не использовать тип переменной в названии.
7) Имена классов и объектов - имена существительные и их комбинации.  
8) Имена методов - глаголы и их комбинации.  
9) Использовать одинаковые названия методов и полей для одинаковой функциональности в разных классов.  
**Если в классах есть метод с одинаковой функциональность, например, получение экземпляра, то во всех классах его необходимо назвать одинаково - ```GetInstance().``` Потому что методы ```GetInstance()``` и ```Get()``` могут дезориентировать того, кто будет читать этот код.**
  
## Methods advices
1) Методы должны насчитывать не более 40 строк.
2) Метод должен выполнять только одну операцию.  
Метод, выполняющий одну операцию, невозможно разделить на логические секции.
3) Содержимое метода должно находиться на одном уровне абстракций.  
**Метод ниже выполняет операции на разных уровнях абстракций.**
```c# 
        /// <summary>
        /// Загружает тексты.
        /// </summary>
        protected override void LoadTexts()
        {
            ///Инициализация объектов.
            ResourceLoader resourceLoader = ResourceLoader.GetForCurrentView();
            
            //Инициализация строк.
            string conditions = resourceLoader.GetString("offerConditionsUid");
            InappProduct saleProduct = _appManager.GetInappProduct(ProductType.OneMonthSale);
            string saleProductPriceString = saleProduct.PriceString;
            
            //Обновление UI.
            Conditions = string.Format(conditions, saleProduct.PriceString);
        }
```
4) Чем меньше аргументов содержит метод, тем лучше.  
Следует избегать 3-х и более аргументов.
5) Если метод принимает аргумент типа ```bool```, то стоит проверить - выполняет ли метод одну задачу.  
Если нет, то метод стоит разбить на несколько методов.
6) Стоит избегать выходных аргументов типа ```out```.
7) Метод должен либо что-то делать, либо отвечать на поставленный вопрос.
8) Обработка ```Try/catch``` должна происходить в отдельном методе.  
Если метод обрабатывает ошибки, то внутри него до и после блока ```try/catch``` не должно быть кода.
9) Следует избегать оператора ```goto```.

## Exception handling rules
1) Необходимо конкретизировать исключения.
2) Необходимо обрабатывать исключения.   

Недопустимо написание подобного кода:
```c#
private void Initialize()
  {
    try
    {
      //do something/
    }
    catch(){ }
  }
```
Код после форматирования:
```c#
private void Initialize()
  {
    try
    {
      //do something/
    }
    catch(StackOverflowException ex)
    {
      string exceptionNote = ex.ToString();
      logger.log(exceptionNote);
    }
    catch(NullReferenceException ex)
    {
      //do something.
    }
  }
```
3) Если мы не знаем, какое конкретно исключение обрабатывать, то допустимо использование ```catch(Exception)```.
4) Необходимо отлавливать принудительно выброшенные исключения.   
```throw new Exception()``` т.д.

## Documentation rules
1) Необходимо документировать классы, конструкторы, методы, поля, свойства и т.д.
2) Документация классов и объектов должна отвечать на вопрос **Что это?**  
```c#
/// <summary>
/// Заявка на пополнение склада товарных позиций.
/// </summary>
public class DeliveryRequest : Entity
```
3) Документация событий должна отвечать на вопрос **Что произошло?**
```c#
/// <summary>
/// Пришла поставка с новыми товарами.
/// </summary>
public class SupplyArrivedWithStockItemsDomainEvent : INotification
```
4) Документация методов должна отвечать на вопрос **Что делает?**
```c#
/// <summary>
/// Возвращает ноту, если она находится по данному индексу.
/// </summary>
public bool TryGetNote(int noteIndex, out NoteDto note)
```
5) Документация полей и свойств типа ```bool``` должна иметь тот вид, при котором на него можно ответить **Да** или **Нет**.
```c#
/// <summary>
/// Активно ли приложение.
/// </summary>
public bool AppIsActive { get; set; }
```
6) Документация и комментарии должны оканчиваться точкой.


## Comments rules
1) «Не комментируйте плохой код — перепишите его» — Брайан Керниган.
2) Информация, которую несет комментарий, должна быть исчерпыващей и понятной.  После прочтения комментария не должно оставаться вопросов.
3) Комментарий должен быть максимально краток и четок.
4) Необходимо удалять закомментированный код.
5) Необходимо оставлять комментарии к логическим элементам в разметке (```XAML```, ```HTML```) т.к. по ним проще ориентироваться в документе.
6) Комментарий должен быть утверждением.
7) Если необходим рефакторинг или реализация фичи, которую в данный момент нет возможности выполнить - необходимо отставить ```TODO``` комментарий.
8) Необходимо комментировать неочевидные проблемы, которые решает код.

## Formatting rules
1) Каждый класс, структура, перечисление и т.д. должны находиться в отдельном файле.
1) Файл не должен превышать 500 строк.
2) Длинна строки не должна превышать 80-120 символов.
4) Перед каждым комментарием, документацией должна быть пустая строка.
5) Не должно быть более 1 отступа.
6) Объявление переменной в методе происходит перед тем местом, в котором она собирается использоваться.
7) Группирование логических фрагментов: 
  - Логические фрагменты в методе должны быть разделены пустыми строками.  
  - Логический фрагмент не должен содержать пустых строк.
```c#
        /// <summary>
        /// Инициализирует экземпляр <see cref="WavePlayerViewModel"/>.
        /// </summary>
        public WavePlayerViewModel()
        {
            Player = new AudioStreamPlayer();
            Selection = new SelectionModel();

            WaveFormViewModel = new WaveFormViewModel(Selection);

            PlayCommand = new RelayCommand(Play, CanPlay);
            PauseCommand = new RelayCommand(Pause, CanPause);

            _adsEventBus = AdsEventBus.Instance;

            InitializeEventHandlers();
        }
```
8) Операции в теле (```if/else```, ```while``` и т.д) должны быть обернуты в фигурные скобки.  
Каждая скобка на отдельной строке.  

**Пример плохого кода:**
```c#
if (_player.IsPlaying)
  _player.Pause();
```
**Код после форматирования:**  
```c#
if (_player.IsPlaying)
{
  _player.Pause();
}
```
9) В каждой строке не более 2 действий.  

**Пример плохого кода:**
```c#
double pointYPosition = Points?.ToList().First(point => point.x == x).Y;
```  
**Код после форматирования:**  
```c#
Point searchedPoint = Points?.First(point => point.X == X);
double pointYPosition = searchedPoint.Y;
```
10) Передавать в параметры метода конкретный объект, а не результат другого метода.
11) Перед ```return``` должна находиться пустая строка.
12) Если после закрывающей скобки ```}``` идет код, то после нее должна находиться пустая строка.

## Classes and structs rules
1)  **Структуры** раскрывают свои данные, а методы, если они есть, не содержат серьезной логики.
2)  **Объекты** скрывают свои данные за абстракциями и предоставляют функции, работающие с этими данными.
3)  Помечать классы модификатором ```sealed```, если не планируется наследование этого класса.
4)  Классы не должны иметь публичных полей. Публичными в классах могут быть только методы и свойства.
5)  Закон **Деметры**:  
Метод объекта может вызывать методы:
- Самого объекта.
- Аргументов метода.
- Любого объекта, созданного в методе.
- Любых полей или свойств объекта.
6)  Вместо того, чтобы получать доступ к полям объекта для выполнения определенного действия, пусть сам объект выполнит это действие.
7) Класс должен максимально скрывать свою структуру и реализацию за уровнями доступа.
8) При желании ослабить уровень доступа, следует начать с поиска способа, сохраняющего приватность. Ослабление инкапсуляции всегда должно быть последней мерой решения проблемы.
9) Имя класса всегда должно отображать его отвественность. Если ответственностей слишком много, значит класс выполняет несколько функций и его следует разделить.
10) Попробуйте написать комментарий, который описывает класс. По такому комментарию можно определить сколько отвественностей лежит на классе.
11) Классы должны иметь слабую связанность.  
**Пример:**  
Пазл контактирует с соседними 4-мя пазлами и поменять один пазл не составит труда, но если пазл будет контактировать с большим кол-вом соседей, то сложность внесения изменений будет расти в геометрической прогрессии.
12) Система должна состоять из множества мелких классов, а не из небольшого кол-ва больших.
13) Если в проекте есть несколько классов, которые можно объединить одной группой, то они должны реализовывать единый интерфейс, через который к ним будет обращаться программа.   
**Пример:** В проекте существует класс теста процессора пк, оперативной памяти, чтения и записи диска. Все эти тесты должны реализовать интерфейс ITest.

Пример плохого кода:
```c#
decimal productPrice = ProductViewModel.Product.Price;
```
Код после рефакторинга:
```c#
decimal productPrice = ProductViewModel.GetProductPrice();
```

## General advices
- Проверять, документировать и чистить код перед каждым коммитом и Merge Request-ом.
- ```DRY``` принцип (Don’t repeat yourself - не повторяйся) - В коде не должно быть повторений логики, иначе при измении логики, придется делать изменения в нескольких местах.
- ```KISS``` принцип (Keep it simple stupid- Делай проще, тупица) - Код должен оставаться простым для понимания и дальнейшего раcширения.
- ```YAGNI``` принцип (You aren't gonna need it - Тебе это не понадобится) - В коде не должно быть неиспользуемых строк, методов, классов, ненужной документации.

## C# optimization advices
- Если количество экземпляров ```enum``` может превышать порядка 1 000 000 элементов, а его перечисление не превышает 256, то этот ```enum``` стоит наследовать от типа ```byte```.
Т.к. в стандартной реализации ```enum``` наследуется от ```int```, то каждый экземпляр перечисления будет занимать ***4 байта*** памяти, что может стать большой проблемой в высоконагруженных модулях.
- Если вы заранее знаете примерное кол-во элементов в коллекции, то стоит задать для нее оценочный Capacity после инициализации. Т.к. при добавлении элементов система не будет каждый раз выделять память под коллекцию, что экономит ресурсы системы. 
